# MySQL 数据库设计和注意事项

## 1. 请使用 InnoDB 存储引擎
InnoDB 有更好的 CPU 和 IO 性能，更好的备份和锁表机制，提高统计和调试效率。
另外，作为一个系统，InnoDB 支持多种关键功能，其中最重要的是事务日志和行级锁。事务日志记录真正的数据库事务，但更重要的是数据崩溃恢复和回滚。
基于 InooDB 方式的 IO，能给予更安全数据保护和更好性能表现。另外，在大多数的情况下，行级锁可以提供更高的并发性能，因为用户只锁定他们正在写的数据，而读数据永远不会被阻塞

## 2. 数据表、数据字段必须加入中文注释
方便日后新人小哥，更快理解熟悉；并且可读性更好
同时在 status 这类字段上标注：0 表示删除，1 表示正常 等枚举值。

## 3. 必须使用 UTF8mb4 字符集
utf8 是通用的字符集，mb4 在 utf8 上进行了扩展，支持 emoji 等新的字符。

## 4. 禁止使用存储过程、视图、触发器、Event、join 等
高并发大数据的互联网业务，架构设计思路是 “解放数据库 CPU，将计算转移到服务层”，数据库擅长存储与索引，CPU 计算在业务层更合理。
如果是低并发，小流量，当我没说

## 5. 禁止存储大文件或者大照片
当图片较多时，分页查询速度明显变慢，之前 1 秒内响应，加了照片字段后，需要 4~5 秒左右才能响应。大文件和照片存储在文件系统，数据库里存 URI 更好

## 6. 表必须有主键，例如自增主键
主键递增，数据行写入可以提高插入性能，可以避免 Page 分裂，减少表碎片提升空间和内存的使用
使用数字类型主键，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率
无主键的表删除，在 ROW 模式的主从架构，会导致备库夯住
更多使用业务主键，在分库分表会有更多便利性。
## 7. 禁止使用外键，如果有外键完整性约束，需要应用程序控制
外键会导致表与表之间耦合，Update 与 Delete 操作都会涉及相关联的表，十分影响 SQL 的性能，甚至会造成死锁。

## 8. 把字段定义为 NOT NULL 并且提供默认值
null 的列使索引 / 索引统计 / 值比较都更加复杂，对 MySQL 来说更难优化。
null 这种类型 MySQL 内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多。
null 值需要更多的存储空，无论是表还是索引中每行中的 null 的列都需要额外的空间来标识。
对 null 的处理时候，只能采用 is null 或 is not null ，而不能采用 =、in、<、<>、!=、not in 这些操作符号
## 9. 禁止使用 TEXT、BLOB 类型
会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能。

## 10. 禁止使用小数存储货币
都 0202 年 了，使用整数吧，小数容易导致 钱对不上 或者 精度问题

## 11. 使用 varchar (20) 存储手机号
涉及到区号或者国家代号，可能出现 +-()
手机号会去做数学运算么？
varchar 可以支持模糊查询，例如：like“138%”
## 12. 禁止使用 ENUM，可使用 TINYINT 代替
增加新的 ENUM 值要做 DDL 操作
ENUM 的内部实际存储就是整数，你以为自己定义的是字符串？
## 13. 关于索引设计
单表索引建议控制在 5 个 以内

索引并不是越多越好！索引可以提高效率同样可以降低效率。

索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。

因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。

禁止在更新十分频繁、区分度不高的属性上建立索引，例如：年龄，性别这种

更新会变更 B + 树，更新频繁的字段建立索引会大大降低数据库性能

性别 这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似

建立组合索引，必须把区分度高的字段放在前面，能够更加有效的过滤数据

## 14. 关于 SQL 使用规范
不要使用 INSERT INTO t_xxx VALUES (xxx)，必须显示指定插入的列属性，容易在增加或者删除字段后出现程序 BUG

不要在 WHERE 条件的属性上使用函数或者表达式
```
# 会导致全表扫描
SELECT uid FROM t_user WHERE from_unixtime(day) >= '2019-10-09'
# 优化写法
SELECT uid FROM t_user WHERE day >= unix_timestamp('2019-10-09 00:00:00')
```
不要负向查询，以及 % 开头的模糊查询
负向查询条件：NOT、!=、<>、!<、!>、NOT IN、NOT LIKE 等，会导致全表扫描
% 开头的模糊查询，会导致全表扫描

如果需要搜索，可以使用全文索引

不要在大表使用 JOIN 查询，禁止大表使用子查询，会产生临时表，消耗较多内存与 CPU，极大影响数据库性能

尽量不要使用 OR 条件，必须改为 IN 查询。旧版本 Mysql 的 OR 查询是不能命中索引的，即使能命中索引，也没有必要

应用程序必须捕获 SQL 异常，并有相应处理

## 15. 多使用 EXPLAIN 优化
做 MySQL 优化，我们要善用 EXPLAIN 查看 SQL 执行计划

以下是优化的注释

列	说明
key	使用到的索引名。如果没有选择索引，值是 NULL。可以强制索引
type	连接类型，一个好的 sql 语句最好可以达到 range 级别。杜绝出现 all 级别
rows	扫描行数，该值是个预估值，心里有数就好了
extra	详细说明，注意常见的不太友好的值有：Using filesort, Using temporary
key_len	索引长度

## 16. SQL 语句中 IN 包含的值不应过多
在使用 IN 的时候，MySQL 对于 IN 做了相应的优化，即将 IN 中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。再例如
```mysql
select id from table_name where num in(1,2,3)
```
对于连续的数值，能用 between 就不要用 in 了，再或者使用连接来替换。

## 17. SELECT 语句务必指明字段名称
SELECT * 增加很多不必要的消耗（cpu、io、内存、网络带宽）；增加了使用覆盖索引的可能性。当表结构发生改变时，前断也需要更新。所以要求直接在 select 后面接上字段名。

## 18. 当只需要一条数据的时候，使用最好使用 limit 1
这是为了使 EXPLAIN 中 type 列达到 const 类型

## 19. 如果排序字段没有用到索引，就尽量少排序
## 20. 如果限制条件中其他字段没有索引，尽量少用 or
or 两边的字段中，如果有一个不是索引字段，而其他条件也不是索引字段，会造成该查询不走索引的情况。很多时候使用 union all 或者是 union (必要的时候) 的方式来代替 “or” 会得到更好的效果

## 21. 尽量用 union all 代替 union
union 和 union all 的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的 CPU 运算，加大资源消耗及延迟。当然，union all 的前提条件是两个结果集没有重复数据。

## 22. 不使用 ORDER BY RAND ()
```mysql
select id from `table_name` order by rand() limit 10000;
# 上面的sql语句，可优化为
select id from `table_name` t1 join (select rand() * (select max(id) from `table_name`) as nid) t2 ont1.id > t2.nid limit 1000;
```
## 23. 使用合理的分页方式以提高分页的效率
```
select id,name from table_name limit 866613, 20
# 使用上述 sql 语句做分页的时候，可能有人会发现，随着表数据量的增加，直接使用 limit 分页查询会越来越慢。
# 优化的方法如下：可以取前一页的最大行数的id，然后根据这个最大的 id 来限制下一页的起点。比如此列中，上一页最大的 id 是 866612 。sql可以采用如下的写法：
select id,name from table_name where id> 866612 limit 20
```
## 24. 避免在 where 子句中对字段进行 null 值判断
对于 null 的判断会导致引擎放弃使用索引而进行全表扫描。前文有说，不使用 null

## 25. 避免在 where 子句中对字段进行表达式操作
```
select user_id,user_project from table_name where age*2=36;
# 中对字段就行了算术运算，这会造成引擎放弃使用索引，建议改成：
select user_id,user_project from table_name where age=36/2;
```
## 26. 对于联合索引来说，要遵守最左前缀法则
举列来说索引含有字段 id,name,school，可以直接用 id 字段，也可以 id,name 这样的顺序，但是 name;school 都无法使用这个索引。所以在创建联合索引的时候一定要注意索引字段顺序，常用的查询字段放在最前面

## 27. 必要时可以使用 force index 来强制查询走某个索引
有的时候 MySQL 优化器采取它认为合适的索引来检索 sql 语句，但是可能它所采用的索引并不是我们想要的。这时就可以采用 force index 来强制优化器使用我们制定的索引。同时也可以为某些条件下，用不到索引的语句，进行强制索引搜索

## 28. 注意范围查询语句
对于联合索引来说，如果存在范围查询，比如 between,>,< 等条件时，会造成后面的索引字段失效。

## 29. 软优化
注意查询语句优化
优化子查询
使用索引
分解表，冷字段也可以和热字段分开
中间表
尽量使用 inner join，避免left join
利用小表去驱动大表，利用
分析表，检查表，优化表
增加冗余字段，减少查询，别什么都拆的很散
分库分表，问就是 一主多从 或者 直接上 多主多从
缓存集群
## 30. 硬优化 - 钱钱钱
a. 配置多核心和频率高的 cpu , 多核心可以执行多个线程.
b. 配置大内存，提高内存，即可提高缓存区容量，因此能减少磁盘 I/O 时间，从而提高响应速度.

c. 配置高速磁盘或合理分布磁盘：高速磁盘提高 I/O , 分布磁盘能提高并行操作的能力.

d. 打个比喻，阿里云的服务器做自建数据库，服务器硬盘最好是 ESSD 那种级别，别给我上高效云盘

## 31. 优化数据库参数
- MySQL 服务的配置参数都在 my.cnf 或 my.ini , 下面列出性能影响较大的几个参数.
- key_buffer_size => 索引缓冲区大小
- table_cache => 能同时打开表的个数
- query_cache_size => 查询缓冲区大小
- query_cache_type => 前面参数的开关，0 表示不使用缓冲区，1 表示使用缓冲区
- 但可以在查询中使用 SQL_NO_CACHE 表示不要使用缓冲区
- 表示在查询中明确指出使用缓冲区才用缓冲区，即 SQL_CACHE.
- sort_buffer_size => 排序缓冲区
- 更多参数 => https://www.mysql.com/cn/why-mysql/performance/index.html

---

# 数据库优化

### 1. 对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。

### 2. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：
```
select id from t where num is null
```
最好不要给数据库留 NULL，尽可能的使用 NOT NULL 填充数据库.

备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用 NULL。

不要以为 NULL 不需要空间，比如：char (100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL 也包含在内），都是占用 100 个字符的空间的，如果是 varchar 这样的变长字段， null 不占用空间。

可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询：
```
select id from t where num = 0
```
### 3. 应尽量避免在 where 子句中使用！= 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描。

### 4. 应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如：
```
select id from t where num=10 or Name = 'admin'
可以这样查询：

select id from t where num = 10
union all
select id from t where Name = 'admin'
```
### 5. in 和 not in 也要慎用，否则会导致全表扫描，如：
```
select id from t where num in(1,2,3)
对于连续的数值，能用 between 就不要用 in 了：

select id from t where num between 1 and 3
很多时候用 exists 代替 in 是一个好的选择：

select num from a where num in(select num from b)
用下面的语句替换：

select num from a where exists(select 1 from b where num=a.num)
```
### 6. 下面的查询也将导致全表扫描：
```
select id from t where name like ‘%abc%’
若要提高效率，可以考虑全文检索。
```
### 7. 如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：
```
select id from t where num = @num
可以改为强制查询使用索引：

select id from t with(index(索引名)) where num = @num
```
### 8. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：
```
select id from t where num/2 = 100
应改为:

select id from t where num = 100*2
```
### 9. 应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：
```
select id from t where substring(name,1,3) = ’abc’       -–name以abc开头的id select id from t where datediff(day,createdate,’2005-11-30′) = 0    -–‘2005-11-30’    --生成的id
应改为:

select id from t where name like 'abc%'
select id from t where createdate >= '2005-11-30' and createdate < '2005-12-1'
```
### 10. 不要在 where 子句中的 “=” 左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。

### 11. 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。

### 12. 不要写一些没有意义的查询，如需要生成一个空表结构：
```
select col1,col2 into #t from t where 1=0
这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：

create table #t(…)
```
### 13.Update 语句，如果只更改 1、2 个字段，不要 Update 全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。

### 14. 对于多张大数据量（这里几百条就算大了）的表 JOIN，要先分页再 JOIN，否则逻辑读会很高，性能很差。

### 15.select count(*) from table；这样不带任何条件的 count 会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。

### 16. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。

### 17. 应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。

### 18. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。

### 19. 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。

### 20. 任何地方都不要使用 select * from t，用具体的字段列表代替 “*”，不要返回用不到的任何字段。

### 21. 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。

### 22. 避免频繁创建和删除临时表，以减少系统表资源的消耗。临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。

### 23. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先 create table，然后 insert。

### 24. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。

### 25. 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过 1 万行，那么就应该考虑改写。

### 26. 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。

### 27. 与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括 “合计” 的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。

### 28. 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。

### 29. 尽量避免大事务操作，提高系统并发能力。

### 30. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。

实际案例分析：拆分大的 DELETE 或 INSERT 语句，批量提交 SQL 语句
　　如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。
　　Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。
　　如果你把你的表锁上一段时间，比如 30 秒钟，那么对于一个有很高访问量的站点来说，这 30 秒所积累的访问进程 / 线程，数据库链接，打开的文件数，可能不仅仅会让你的 WEB 服务崩溃，还可能会让你的整台服务器马上挂了。
　　所以，如果你有一个大的处理，你一定把其拆分，使用 LIMIT oracle(rownum),sqlserver(top) 条件是一个好的方法。下面是一个 mysql 示例：
```
while(1){
 　　//每次只做1000条
　　 mysql_query(“delete from logs where log_date <= ’2012-11-01’ limit 1000”);
 　　if(mysql_affected_rows() == 0){
　　 　　//删除完成，退出！
　　 　　break；
　　}
//每次暂停一段时间，释放表让其他进程/线程访问。
usleep(50000)
}
```